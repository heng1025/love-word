// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Qs from "qs";
import Md5 from "md5";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as $$Promise from "@ryyppy/rescript-promise/src/Promise.js";
import * as FrancMin from "franc-min";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var endpoint = "http://dict.1r21.cn/dict";

function translate(q) {
  return $$Promise.$$catch(fetch("" + endpoint + "?q=" + q + "", undefined).then(function (res) {
                    return res.json();
                  }).then(function (data) {
                  return Promise.resolve(data !== undefined ? ({
                                  TAG: /* Ok */0,
                                  _0: Caml_option.valFromOption(data)
                                }) : ({
                                  TAG: /* Error */1,
                                  _0: "Word can not find"
                                }));
                }), (function (e) {
                var msg;
                if (e.RE_EXN_ID === $$Promise.JsError) {
                  var msg$1 = e._1.message;
                  msg = msg$1 !== undefined ? msg$1 : "";
                } else {
                  msg = "Unexpected error occurred";
                }
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: msg
                          });
              }));
}

var OfflineDict = {
  endpoint: endpoint,
  translate: translate
};

var endpoint$1 = "https://api.fanyi.baidu.com/api/trans/vip/translate";

function textToSpeech(text) {
  var query = Qs.stringify({
        word: text,
        le: "zh"
      });
  return "https://tts.youdao.com/fanyivoice?" + query + "";
}

function translate$1(q) {
  return $$Promise.$$catch(chrome.storage.local.get(["baiduKey"]).then(function (result) {
                        var appid = result.baiduKey.appid;
                        var key = result.baiduKey.secret;
                        var salt = Date.now().toString();
                        var sign = Md5(appid + q + salt + key);
                        var sl = FrancMin.franc(q, {
                              minLength: 1,
                              only: [
                                "eng",
                                "cmn"
                              ]
                            });
                        var tlDict = Js_dict.fromList({
                              hd: [
                                "cmn",
                                "en"
                              ],
                              tl: /* [] */0
                            });
                        var val = Js_dict.get(tlDict, sl);
                        var query = Qs.stringify({
                              q: q,
                              from: "auto",
                              to: val !== undefined ? val : "zh",
                              appid: appid,
                              salt: salt,
                              sign: sign
                            });
                        return "" + endpoint$1 + "?" + query + "";
                      }).then(function (ret) {
                      return fetch(ret, undefined);
                    }).then(function (res) {
                    return res.json();
                  }).then(function (data) {
                  var msg = data.error_msg;
                  var tmp;
                  if (msg !== undefined) {
                    tmp = {
                      TAG: /* Error */1,
                      _0: msg
                    };
                  } else {
                    var val = data.trans_result;
                    tmp = val !== undefined ? ({
                          TAG: /* Ok */0,
                          _0: val
                        }) : ({
                          TAG: /* Error */1,
                          _0: "No Translation"
                        });
                  }
                  return Promise.resolve(tmp);
                }), (function (e) {
                var msg;
                if (e.RE_EXN_ID === $$Promise.JsError) {
                  var msg$1 = e._1.message;
                  msg = msg$1 !== undefined ? msg$1 : "";
                } else {
                  msg = "Unexpected error occurred";
                }
                return Promise.resolve({
                            TAG: /* Error */1,
                            _0: msg
                          });
              }));
}

var Baidu = {
  endpoint: endpoint$1,
  textToSpeech: textToSpeech,
  translate: translate$1
};

function adapterTrans(text) {
  var sl = FrancMin.franc(text, {
        minLength: 1,
        only: [
          "eng",
          "cmn"
        ]
      });
  var wordCount = text.split(" ");
  var baiduResult = function (param) {
    return translate$1(text).then(function (br) {
                var tmp;
                tmp = br.TAG === /* Ok */0 ? ({
                      TAG: /* Baidu */1,
                      _0: br._0
                    }) : ({
                      TAG: /* Message */2,
                      _0: br._0
                    });
                return Promise.resolve(tmp);
              });
  };
  if (sl !== "eng" || wordCount.length > 4) {
    return baiduResult(undefined);
  } else {
    return translate(text).then(function (ret) {
                if (ret.TAG === /* Ok */0) {
                  return Promise.resolve({
                              TAG: /* Dict */0,
                              _0: ret._0
                            });
                } else {
                  return baiduResult(undefined);
                }
              });
  }
}

export {
  OfflineDict ,
  Baidu ,
  adapterTrans ,
}
/* qs Not a pure module */
