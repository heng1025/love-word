// Generated by ReScript, PLEASE EDIT WITH CARE

import Md5 from "md5";
import * as Utils from "../src/Utils.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Fixture from "./utils/Fixture.js";
import * as FrancMin from "franc-min";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

function createFranc(prim0, prim1) {
  return FrancMin.franc(prim0, prim1);
}

function _createMd5(prim) {
  return Md5(prim);
}

vi.mock("franc-min", undefined);

vi.mock("md5", undefined);

var Unknown = /* @__PURE__ */Caml_exceptions.create("UtilsTest.Unknown");

var mockChromeStore = {
  user: "iron",
  baiduKey: {
    appid: "testAppid",
    secret: "testSecret"
  }
};

Fixture.chromeGetStoreSpy.mockResolvedValue(mockChromeStore);

function libSuite() {
  test("fetchByHttp works", (async function () {
          var ret = Fixture.createMockHttpResponse(undefined, undefined, {
                word: "hello"
              });
          Fixture.fetchSpy.mockResolvedValue(ret);
          var res = await Utils.Lib.fetchByHttp("/dict", undefined, undefined);
          expect(res).toStrictEqual({
                TAG: "Ok",
                _0: ret.json().data
              });
        }));
  test("fetchByHttp works with error", (async function () {
          var ret = Fixture.createMockHttpResponse(2, "error", undefined);
          Fixture.fetchSpy.mockResolvedValue(ret);
          var res = await Utils.Lib.fetchByHttp("/dict", undefined, undefined);
          expect(res).toStrictEqual({
                TAG: "Error",
                _0: ret.json().msg
              });
        }));
  test.each([
          {
            exn: (function () {
                return Js_exn.raiseError("js error");
              }),
            expected: "js error"
          },
          {
            exn: (function () {
                throw {
                      RE_EXN_ID: "Not_found",
                      Error: new Error()
                    };
              }),
            expected: "Unexpected error occurred"
          }
        ])("fetchByHttp works with $expected  exception", (async function (cases) {
          Fixture.fetchSpy.mockImplementation(function () {
                return cases.exn();
              });
          var res = await Utils.Lib.fetchByHttp("/dict", undefined, undefined);
          expect(res).toStrictEqual({
                TAG: "Error",
                _0: cases.expected
              });
        }));
  test("debounce works", (function () {
          vi.useFakeTimers();
          var callbackSpy = vi.fn(undefined);
          var match = Utils.Lib.debounce(1000, callbackSpy);
          match[0]();
          expect(callbackSpy).not.toHaveBeenCalled();
          vi.runAllTimers();
          expect(callbackSpy).toHaveBeenCalled();
        }));
  test("debounce works with cancel", (function () {
          vi.useFakeTimers();
          var callbackSpy = vi.fn(undefined);
          var match = Utils.Lib.debounce(1000, callbackSpy);
          match[0]();
          match[1]();
          vi.runAllTimers();
          expect(callbackSpy).not.toHaveBeenCalled();
        }));
}

function baiduSuite() {
  Md5.mockReturnValue("mockSign");
  FrancMin.franc.mockReturnValue("cmn");
  test("Baidu translate endpoint", (function () {
          expect("https://api.fanyi.baidu.com/api/trans/vip/translate").toStrictEqual(Utils.Baidu.endpoint);
        }));
  test("textToSpeech works", (function () {
          var url = Utils.Baidu.textToSpeech("hello");
          expect(url).toStrictEqual("https://dict.youdao.com/dictvoice?audio=hello&le=zh");
        }));
  test("Baidu translate works", (async function () {
          var mockBaiduReturn = {
            json: (function () {
                return {
                        trans_result: Fixture.baiduData
                      };
              })
          };
          Fixture.fetchSpy.mockResolvedValue(mockBaiduReturn);
          var ret = await Utils.Baidu.translate("你好");
          expect(ret).toStrictEqual({
                TAG: "Ok",
                _0: Fixture.baiduData
              });
        }));
  test("Baidu translate works with no result", (async function () {
          var mockBaiduReturn = {
            json: (function () {
                return {
                        trans_result: undefined
                      };
              })
          };
          Fixture.fetchSpy.mockResolvedValue(mockBaiduReturn);
          var ret = await Utils.Baidu.translate("你好");
          expect(ret).toStrictEqual({
                TAG: "Error",
                _0: "No Translation"
              });
        }));
  test("Baidu translate works with error_msg", (async function () {
          var mockBaiduReturn = {
            json: (function () {
                return {
                        error_msg: "error"
                      };
              })
          };
          Fixture.fetchSpy.mockResolvedValue(mockBaiduReturn);
          var ret = await Utils.Baidu.translate("你好");
          expect(ret).toStrictEqual({
                TAG: "Error",
                _0: "error"
              });
        }));
  test.each([
          {
            exn: (function () {
                return Js_exn.raiseError("js error");
              }),
            expected: "js error"
          },
          {
            exn: (function () {
                throw {
                      RE_EXN_ID: "Not_found",
                      Error: new Error()
                    };
              }),
            expected: "Unexpected error occurred"
          }
        ])("Baidu translate works works with $expected exception", (async function (cases) {
          Fixture.fetchSpy.mockImplementation(function () {
                return cases.exn();
              });
          var res = await Utils.Lib.fetchByHttp("/dict", undefined, undefined);
          expect(res).toStrictEqual({
                TAG: "Error",
                _0: cases.expected
              });
        }));
  test("Baidu translate works with no appid", (async function () {
          Fixture.chromeGetStoreSpy.mockReturnValue();
          var ret = await Utils.Baidu.translate("你好");
          expect(ret).toStrictEqual({
                TAG: "Error",
                _0: "No translation key"
              });
          Fixture.chromeGetStoreSpy.mockReturnValue({
                baiduKey: null
              });
          var ret$1 = await Utils.Baidu.translate("你好");
          expect(ret$1).toStrictEqual({
                TAG: "Error",
                _0: "No translation key"
              });
          Fixture.chromeGetStoreSpy.mockResolvedValue(mockChromeStore);
        }));
}

describe("Utils module", (function () {
        describe("Lib module", libSuite);
        describe("Baidu translate module", baiduSuite);
        test("includeWith works", (function () {
                var res = Utils.includeWith("hello", "he");
                expect(res).toBe(true);
              }));
        test("OfflineDict translate works", (async function () {
                var ret = Fixture.createMockHttpResponse(undefined, undefined, Fixture.dictData);
                Fixture.fetchSpy.mockResolvedValue(ret);
                var res = await Utils.OfflineDict.translate("hello");
                expect(res).toStrictEqual({
                      TAG: "Ok",
                      _0: Fixture.dictData
                    });
              }));
        test.each([
                "favorite",
                "history"
              ])("recordRemoteAction works %s", (async function (recordType) {
                var ret = Fixture.createMockHttpResponse(undefined, undefined, Fixture.dictData);
                Fixture.fetchSpy.mockResolvedValue(ret);
                var res = await Utils.recordRemoteAction(recordType, undefined, undefined);
                expect(res).toStrictEqual({
                      TAG: "Ok",
                      _0: Fixture.dictData
                    });
              }));
        test("recordRemoteAction works with error", (async function () {
                Fixture.chromeGetStoreSpy.mockReturnValue({
                      user: undefined
                    });
                var res = await Utils.recordRemoteAction("favorite", undefined, undefined);
                expect(res).toStrictEqual({
                      TAG: "Error",
                      _0: "nothing"
                    });
                Fixture.chromeGetStoreSpy.mockResolvedValue(mockChromeStore);
              }));
      }));

export {
  createFranc ,
  _createMd5 ,
  Unknown ,
  mockChromeStore ,
  libSuite ,
  baiduSuite ,
}
/*  Not a pure module */
