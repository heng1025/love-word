// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fixture from "../utils/Fixture.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as RecordHook from "../../src/hooks/RecordHook.js";
import * as React from "@testing-library/react";

var wordRecords = [
  Fixture.dictRecord,
  Fixture.baiduRecord
];

var sendMessageSpy = vi.spyOn(chrome.runtime, "sendMessage");

function initRecords(recordType) {
  return React.renderHook(function () {
              return RecordHook.useRecord(recordType);
            }).result;
}

describe.each([
        "favorite",
        "history"
      ])("useRecordHook works for %s", (function (recordType) {
        beforeAll(function () {
              return sendMessageSpy.mockResolvedValue(wordRecords);
            });
        afterAll(function () {
              vi.clearAllMocks();
            });
        test("get all favorite records", (async function () {
                var result = initRecords(recordType);
                return await React.waitFor((function () {
                              var current = result.current;
                              expect(current.records).toStrictEqual(wordRecords);
                            }), undefined);
              }));
        test("search records without keyword", (async function () {
                var result = initRecords(recordType);
                React.act(function () {
                      var current = result.current;
                      current.onSearch("");
                    });
                return await React.waitFor((function () {
                              var current = result.current;
                              expect(current.records).toHaveLength(2);
                              expect(current.records).toStrictEqual(wordRecords);
                            }), undefined);
              }));
        test("seach records with results", (async function () {
                var result = initRecords(recordType);
                await React.waitFor((function () {
                        
                      }), undefined);
                React.act(function () {
                      var current = result.current;
                      current.onSearch("hello");
                    });
                var current = result.current;
                expect(current.records).toHaveLength(1);
              }));
        test("seach records without results", (async function () {
                var result = initRecords(recordType);
                await React.waitFor((function () {
                        
                      }), undefined);
                React.act(function () {
                      var current = result.current;
                      current.onSearch("abc");
                    });
                var current = result.current;
                expect(current.records).toHaveLength(0);
              }));
        test("check records", (async function () {
                var result = initRecords(recordType);
                await React.waitFor((function () {
                        
                      }), undefined);
                React.act(function () {
                      var current = result.current;
                      current.onCheck(Fixture.dictRecord);
                    });
                var current = result.current;
                var checkedRecords = current.records.filter(function (r) {
                      return r.checked;
                    });
                expect(checkedRecords).toHaveLength(1);
                expect(checkedRecords[0].text).toBe(Fixture.dictRecord.text);
              }));
        test("cancle checked", (async function () {
                var result = initRecords(recordType);
                React.act(function () {
                      var current = result.current;
                      current.onCancel();
                    });
                return await React.waitFor((function () {
                              var current = result.current;
                              var isAllUnchecked = current.records.every(function (r) {
                                    return r.checked === false;
                                  });
                              expect(isAllUnchecked).toBe(true);
                            }), undefined);
              }));
        test("delete records", (async function () {
                var result = initRecords(recordType);
                React.act(function () {
                      sendMessageSpy.mockResolvedValue([Fixture.baiduRecord]);
                      var current = result.current;
                      var newrecord = Caml_obj.obj_dup(Fixture.dictRecord);
                      current.onDelete([(newrecord.checked = true, newrecord)]);
                    });
                return await React.waitFor((function () {
                              var current = result.current;
                              expect(current.records).toHaveLength(1);
                            }), undefined);
              }));
        test("clear records", (async function () {
                var result = initRecords(recordType);
                React.act(function () {
                      sendMessageSpy.mockResolvedValue([]);
                      var current = result.current;
                      current.onClear();
                    });
                return await React.waitFor((function () {
                              var current = result.current;
                              expect(current.records).toHaveLength(0);
                            }), undefined);
              }));
        test("sync records", (async function () {
                var result = initRecords(recordType);
                React.act(function () {
                      var newrecord = Caml_obj.obj_dup(Fixture.dictRecord);
                      var updatedRecords = [
                        (newrecord.sync = true, newrecord.checked = true, newrecord),
                        Fixture.baiduRecord
                      ];
                      sendMessageSpy.mockResolvedValue(updatedRecords);
                      var current = result.current;
                      var newrecord$1 = Caml_obj.obj_dup(Fixture.dictRecord);
                      current.onSync([(newrecord$1.checked = true, newrecord$1)]);
                    });
                return await React.waitFor((function () {
                              var current = result.current;
                              var syncedRecords = current.records.filter(function (r) {
                                    return r.sync;
                                  });
                              expect(syncedRecords).toHaveLength(1);
                              expect(syncedRecords[0].text).toBe(Fixture.dictRecord.text);
                            }), undefined);
              }));
      }));

export {
  wordRecords ,
  sendMessageSpy ,
  initRecords ,
}
/* sendMessageSpy Not a pure module */
